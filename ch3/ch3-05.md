## 3.5. 字符串

一个字符串是一个不可改变的字节序列. 字符串可以包含任意的数据, 包括字节值0, 但是通常包含人类可读的文本. 文本字符串通常被解释为采用UTF8编码的Unicode码点(rune)序列, 我们稍后会详细讨论这个问题.

内置的 len 函数可以返回一个字符串的字节数目(不是rune字符数目), 索引操作 s[i] 返回第i个字节的字节值, i 必须满足 0 ≤ i< len(s) 条件约束.

```Go
s := "hello, world"
fmt.Println(len(s))     // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')
```

Attempting to access a byte outside this range results in a panic:

如果视图访问超出字符串范围的字节将会导致panic异常:

```Go
c := s[len(s)] // panic: index out of range
```

第i个字节并不一定是字符串的第i个字符, 因此对于非ASCII字符的UTF8编码会要两个或多个字节. 我们简单说下字符的工作方式.

子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节(并不包含j本身)生成一个新字符串. 生成的子字符串将包含 j-i 个字节.

```Go
fmt.Println(s[0:5]) // "hello"
```

同样, 如果索引超出字符串范围或者j小于i的话将导致panic异常.

不管i还是j都可能被忽略, 当它们被忽略时将采用0作为开始位置, 采用 len(s) 作为接受的位置.

```Go
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:])  // "hello, world"
```

其中 + 操作符将两个字符串链接构造一个新字符串:

```Go
fmt.Println("goodbye" + s[5:]) // "goodbye, world"
```

字符串可以用 == 和 < 进行比较; 比较通过逐个字节比较完成的, 因此比较的结果是字符串自然编码的顺序.


字符串的值是不可变的: 一个字符串包含的字节序列永远不会被改变, 当然我们也可以给一个字符串变量分配一个新字符串值. 可以像下面这样将一个字符串追加到另一个字符串

```Go
s := "left foot"
t := s
s += ", right foot"
```

这并不会导致原始的字符串值被改变, 但是 s 将因为 += 语句持有一个新的字符串值, 但是 t 依然是包含原先的字符串值.

```Go
fmt.Println(s) // "left foot, right foot"
fmt.Println(t) // "left foot"
```

因为字符串是不可修改的, 因此尝试修改字符串内部数据的操作是被禁止的:

```Go
s[0] = 'L' // compile error: cannot assign to s[0]
```

不变性意味如果两个字符串共享相同的底层数据是安全的, 这使得复制任何长度的字符串代价是低廉的. 同样, 一个字符串 s 和对应的子字符串 s[7:] 也可以安全地共享相同的内存, 因此字符串切片操作代价也是低廉的. 在这两种情况下都没有必要分配新的内存. 图3.4 演示了一个字符串和两个字串共享相同的底层数据.


{% include "./ch3-03-1.md" %}

{% include "./ch3-03-2.md" %}

{% include "./ch3-03-3.md" %}

{% include "./ch3-03-4.md" %}

{% include "./ch3-03-5.md" %}



